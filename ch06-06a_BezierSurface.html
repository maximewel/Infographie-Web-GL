<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"/><link rel="stylesheet" href="./css/stylesheet.css"><script src="./js/commonFunctions.js"></script><script src='./js/gl-matrix-min.js'></script> <script src='./js/webglTools.js'> </script> <script id="shader-vs" type="x-shader/x-vertex"> attribute vec3 aVertexPosition; attribute vec4 aColor; uniform int uAction; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform vec3 uP0; uniform vec3 uP1; uniform vec3 uP2; uniform vec3 uP3; uniform vec3 uP4; uniform vec3 uP5; uniform vec3 uP6; uniform vec3 uP7; uniform vec3 uP8; varying vec4 vColor; void main(void){if(uAction==2){vColor=aColor; float t=0.0; gl_PointSize=2.0; t=aVertexPosition.y; vec3 row0=(1.0-t) * ((1.0-t) * uP0 + t * uP1) + t * ((1.0-t) * uP1 + t * uP2); vec3 row1=(1.0-t) * ((1.0-t) * uP3 + t * uP4) + t * ((1.0-t) * uP4 + t * uP5); vec3 row2=(1.0-t) * ((1.0-t) * uP6 + t * uP7) + t * ((1.0-t) * uP7 + t * uP8); t=aVertexPosition.x; vec3 col0=(1.0-t) * ((1.0-t) * uP0 + t * uP3) + t * ((1.0-t) * uP3 + t * uP6); vec3 col1=(1.0-t) * ((1.0-t) * uP1 + t * uP4) + t * ((1.0-t) * uP4 + t * uP7); vec3 col2=(1.0-t) * ((1.0-t) * uP2 + t * uP5) + t * ((1.0-t) * uP5 + t * uP8); vec3 sumCols=col0 + col1 + col2; vec3 sumRows=row0 + row1 + row2; vec3 surfaceVertex=vec3(sumCols.x/3.0, sumRows.y/3.0, (sumCols.z + sumRows.z)/3.0); gl_Position=uPMatrix * uMVMatrix * vec4(surfaceVertex, 1.0);}else if(uAction==1){vColor=aColor; float t=aVertexPosition.x; vec3 intermedPosition=(1.0-t) * ((1.0-t) * uP0 + t * uP1) + t * ((1.0-t) * uP1 + t * uP2); gl_Position=uPMatrix * uMVMatrix * vec4(intermedPosition, 1.0);}else if (uAction==0){vColor=vec4(0.0,0.0,0.0,1.0); gl_PointSize=5.0; gl_Position=uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);}}</script> <script id="shader-fs" type="x-shader/x-fragment"> #ifdef GL_ES 
	precision highp float; 
	#endif 
	varying vec4 vColor; void main(void){gl_FragColor=vColor;}</script> <script>var vertexBuffer=null; var indexBuffer=null; var colorBuffer=null; var indices=[]; var vertices=[]; var colors=[]; var mvMatrix=mat4.create(); var pMatrix=mat4.create(); var rotY=0.0; var firstRun=true; var referencePoints=[];function initShaderParameters(prg){prg.vertexPositionAttribute=glContext.getAttribLocation(prg, "aVertexPosition"); glContext.enableVertexAttribArray(prg.vertexPositionAttribute); prg.colorAttribute=glContext.getAttribLocation(prg, "aColor"); glContext.enableVertexAttribArray(prg.colorAttribute); prg.pMatrixUniform=glContext.getUniformLocation(prg, 'uPMatrix'); prg.mvMatrixUniform=glContext.getUniformLocation(prg, 'uMVMatrix'); prg.p0Uniform=glContext.getUniformLocation(prg, 'uP0'); prg.p1Uniform=glContext.getUniformLocation(prg, 'uP1'); prg.p2Uniform=glContext.getUniformLocation(prg, 'uP2'); prg.p3Uniform=glContext.getUniformLocation(prg, 'uP3'); prg.p4Uniform=glContext.getUniformLocation(prg, 'uP4'); prg.p5Uniform=glContext.getUniformLocation(prg, 'uP5'); prg.p6Uniform=glContext.getUniformLocation(prg, 'uP6'); prg.p7Uniform=glContext.getUniformLocation(prg, 'uP7'); prg.p8Uniform=glContext.getUniformLocation(prg, 'uP8'); prg.actionUniform=glContext.getUniformLocation(prg, "uAction");}function initBuffers(){indices=[]; vertices=[]; colors=[]; referencePoints=[]; referencePoints.push( -0.45, 0.45, 0); referencePoints.push( -0.45, 0.0, 0); referencePoints.push( -0.45, -0.45, 0); referencePoints.push( 0.0, 0.45, 0); referencePoints.push( 0.0, 0.0, 0.9); referencePoints.push( 0.0, -0.45, 0); referencePoints.push( 0.45, 0.45, 0); referencePoints.push( 0.45, 0.0, 0); referencePoints.push( 0.45, -0.45, 0);}function setBuffersForPoints(){indices=[]; vertices=[]; colors=[]; vertices=referencePoints; for(var i=0; i < vertices.length/3; ++i){colors.push( 0.0, 0.0, 1.0, 1.0 ); indices.push(i);}vertexBuffer=getVertexBufferWithVertices(vertices); indexBuffer=getIndexBufferWithIndices(indices); colorBuffer=getVertexBufferWithVertices(colors);}function setBuffersForLine(r,g,b){indices=[]; vertices=[]; colors=[]; var MAX_INTERMEDIATE_POINTS=20.0; for(var i=0; i <=MAX_INTERMEDIATE_POINTS; ++i){var t=1.0/MAX_INTERMEDIATE_POINTS*i; vertices.push( t, 0, 0); colors.push( t*r, t*g, t*b, 1.0 );}for(var i=0; i < vertices.length/3; ++i){indices.push(i);}vertexBuffer=getVertexBufferWithVertices(vertices); indexBuffer=getIndexBufferWithIndices(indices); colorBuffer=getVertexBufferWithVertices(colors);}function setBuffersForSurface(r,g,b){indices=[]; vertices=[]; colors=[]; var MAX_INTERMEDIATE_POINTS=20.0; var t=0.0; for(var column=0; column < MAX_INTERMEDIATE_POINTS; ++column){for(var y=0; y <=MAX_INTERMEDIATE_POINTS; ++y){for(var x=column; x < column +2; ++x){t=1.0/MAX_INTERMEDIATE_POINTS*x; vertices.push( t, 1.0/MAX_INTERMEDIATE_POINTS*y, 0 ); colors.push( r, g, b, 1.0 ); if(firstRun){console.log(t+", "+1.0/MAX_INTERMEDIATE_POINTS*y);}}}}firstRun=false; for(var i=0; i < vertices.length/3; ++i){indices.push(i);}vertexBuffer=getVertexBufferWithVertices(vertices); indexBuffer=getIndexBufferWithIndices(indices); colorBuffer=getVertexBufferWithVertices(colors);}function drawVertexSet(style, actionValue){glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer); glContext.uniform1i(prg.actionUniform, actionValue);glContext.drawElements(style, indices.length, glContext.UNSIGNED_SHORT,0);}function drawScene(){glContext.clearColor(0.9, 0.9, 1.0, 1.0); glContext.enable(glContext.DEPTH_TEST); glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT); glContext.viewport(0, 0, c_width, c_height); mat4.perspective(pMatrix, degToRad(60), c_width / c_height, 0.1, 10000.0); mat4.identity(mvMatrix); mat4.translate(mvMatrix, mvMatrix, [0,0,-1.3]); mat4.rotate(mvMatrix, mvMatrix, rotY, [0, 1, 0]); rotY +=0.005; if (rotY > Math.PI*2) rotY=0; glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix); glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix); setBuffersForPoints(); drawVertexSet(glContext.POINTS,0); for(i=0; i < 3; i++){var offset=i * 9; glContext.uniform3fv(prg.p0Uniform, referencePoints.slice(offset + 0, offset + 3)); glContext.uniform3fv(prg.p1Uniform, referencePoints.slice(offset + 3, offset + 6)); glContext.uniform3fv(prg.p2Uniform, referencePoints.slice(offset + 6, offset + 9)); setBuffersForLine(0.0,1.0,0.0); drawVertexSet(glContext.LINE_STRIP,1);}for(i=0; i < 3; i++){var offset=i * 3; glContext.uniform3fv(prg.p0Uniform, referencePoints.slice(offset + 0, offset + 3)); glContext.uniform3fv(prg.p1Uniform, referencePoints.slice(offset + 9, offset + 12)); glContext.uniform3fv(prg.p2Uniform, referencePoints.slice(offset + 18, offset + 21)); setBuffersForLine(1.0,0.0,0.0); drawVertexSet(glContext.LINE_STRIP,1);}glContext.uniform3fv(prg.p0Uniform, referencePoints.slice(0, 3)); glContext.uniform3fv(prg.p1Uniform, referencePoints.slice(3, 6)); glContext.uniform3fv(prg.p2Uniform, referencePoints.slice(6, 9)); glContext.uniform3fv(prg.p3Uniform, referencePoints.slice(9, 12)); glContext.uniform3fv(prg.p4Uniform, referencePoints.slice(12, 15)); glContext.uniform3fv(prg.p5Uniform, referencePoints.slice(15, 18)); glContext.uniform3fv(prg.p6Uniform, referencePoints.slice(18, 21)); glContext.uniform3fv(prg.p7Uniform, referencePoints.slice(21, 24)); glContext.uniform3fv(prg.p8Uniform, referencePoints.slice(24, 27));setBuffersForSurface(1,1,1);drawVertexSet(glContext.LINE_STRIP,2);setBuffersForSurface(0.5,0.5,0.9);drawVertexSet(glContext.TRIANGLE_STRIP,2);}function initWebGL(){glContext=getGLContext('webgl-canvas'); initProgram(); initBuffers(); renderLoop();}</script> </head> <body onload="initWebGL()"> <script>displayTitle("Ch.06 Ex.6a : Surface quadrique de BÃ©zier", 1,1,1,1,1,1,1); </script> <p> Pas d'interactions utilisateur possible. </p><canvas id="webgl-canvas" width="500" height="500"> HTML5 is not supported </canvas> </body> <script id='code-js' type="text/javascript"> </script></html>